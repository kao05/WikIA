{
  "modulo_educativo": {
    "metadata": {
      "id": "induccion_matematica",
      "titulo": "Inducción Matemática",
      "materia": "Matemáticas Discretas",
      "semestre": 1,
      "dificultad": "difícil",
      "tiempo_estudio": "4-6 horas"
    },
    "contenido": {
      "conceptos_clave": {
        "titulo": "¿Qué es la Inducción Matemática?",
        "definicion": "Es un método de demostración lógica utilizado para probar que una proposición es verdadera para todos los números naturales (1, 2, 3...). Es el equivalente matemático al 'Efecto Dominó'.",
        "puntos_clave": [
          "Paso Base (El primer dominó): Demostrar que la fórmula funciona para n=1.",
          "Hipótesis Inductiva: Asumir que la fórmula es verdadera para un número genérico 'k'.",
          "Paso Inductivo (El golpe): Demostrar que si funciona para 'k', entonces OBLIGATORIAMENTE funciona para 'k+1'.",
          "Conclusión: Si cae el primero y cada uno tira al siguiente, caen todos."
        ],
        "formulas": [
          "Suma de n enteros (Gauss): 1 + 2 + ... + n = n(n+1)/2",
          "Suma de impares: 1 + 3 + ... + (2n-1) = n²",
          "Desigualdad de Bernoulli: (1+x)^n ≥ 1+nx"
        ]
      },
      "utilidad_practica": {
        "titulo": "La base de la Recursividad",
        "descripcion": "En Ciencias de la Computación, la inducción no es solo teórica; es la única forma de garantizar que un algoritmo recursivo es correcto y termina.",
        "aplicaciones_comunes": [
          "Verificación de Algoritmos: Probar matemáticamente que un código hace lo que dice hacer.",
          "Diseño de Funciones Recursivas: El 'Caso Base' de la recursión es el 'Paso Base' de la inducción.",
          "Cálculo de Complejidad: Demostrar que un algoritmo MergeSort siempre toma O(n log n).",
          "Invariantes de Bucle: Demostrar que un bucle 'while' siempre produce el resultado correcto al terminar."
        ],
        "ejemplos_vida_real": [
          "Blockchain: La validez de un bloque depende criptográficamente de la validez del bloque anterior (cadena inductiva).",
          "Compiladores: Analizar estructuras de código anidadas (paréntesis dentro de paréntesis).",
          "Protocolos de Red: Asegurar que si el paquete 1 llega, y el mecanismo de retransmisión funciona para k, funcionará para toda la transmisión."
        ]
      },
      "mapa_conocimiento": {
        "titulo": "Estructura Lógica",
        "prerequisitos": [
          {
            "id": "logica_predicados",
            "nombre": "Lógica de Predicados",
            "razon": "Necesitas entender qué significa P(n) y cuantificadores universales (para todo n)."
          },
          {
            "id": "algebra_basica",
            "nombre": "Álgebra Elemental",
            "razon": "Manipulación algebraica para probar que el lado izquierdo es igual al derecho."
          }
        ],
        "temas_siguientes": [
          {
            "id": "recursividad_programacion",
            "nombre": "Recursividad (Programación)",
            "razon": "La inducción es la teoría; la recursividad es la práctica."
          },
          {
            "id": "analisis_algoritmos",
            "nombre": "Análisis de Algoritmos",
            "razon": "Usarás inducción para resolver ecuaciones de recurrencia."
          }
        ],
        "conceptos_auxiliares": [
          "Series y Sucesiones",
          "Invariantes de ciclo",
          "Prueba por contradicción"
        ]
      },
      "contexto_profesional": {
        "aplicaciones_industria": {
          "titulo": "Ingeniería de Software Crítica",
          "sectores": [
            {
              "nombre": "Sistemas Críticos (Aeroespacial / Medicina)",
              "descripcion": "Donde un error de software puede costar vidas, se usa 'Verificación Formal' basada en inducción.",
              "ejemplos": ["Software de control de vuelos", "Marcapasos"]
            },
            {
              "nombre": "Criptografía y Blockchain",
              "descripcion": "Garantizar seguridad en cadenas de bloques de longitud indefinida.",
              "ejemplos": ["Protocolos de consenso", "Validación de transacciones"]
            }
          ],
          "empresas_referencia": [
            "NASA / SpaceX (Sistemas de control)",
            "Empresas de Trading de Alta Frecuencia (Algoritmos financieros)",
            "Microsoft Research (Verificación de software)"
          ]
        },
        "roles_laborales": {
          "titulo": "Perfiles Especializados",
          "salario_promedio_mx": "$45,000 - $85,000 MXN/mes",
          "roles": [
            {
              "nombre": "Ingeniero de Verificación Formal",
              "importancia": "Crítica",
              "uso": "Matemáticas rigurosas para auditar código."
            },
            {
              "nombre": "Investigador en Ciencias de la Computación",
              "importancia": "Alta",
              "uso": "Desarrollo de nuevos algoritmos y pruebas de eficiencia."
            },
            {
              "nombre": "Ingeniero de Algoritmos",
              "importancia": "Media",
              "uso": "Optimización basada en pruebas matemáticas."
            }
          ]
        }
      }
    },
    "actividad_practica": {
      "tipo": "reto_programacion",
      "titulo": "Reto: Carrera de Algoritmos (Fórmula vs Iteración)",
      "descripcion": "La inducción nos da fórmulas 'cerradas' (instantáneas) para sumas que normalmente requerirían bucles. Tu reto es implementar ambas soluciones y comparar su rendimiento para demostrar el poder de la inducción.",
      "dificultad": "básico",
      "instrucciones": [
        "Problema: Calcular la suma de los primeros 'n' números naturales.",
        "Implementa 'suma_iterativa(n)': Usa un bucle for/while para sumar 1+2+...+n.",
        "Implementa 'suma_formula(n)': Usa la fórmula probada por inducción n(n+1)/2.",
        "Compara el tiempo de ejecución con un número gigante (ej. 10,000,000)."
      ],
      "codigo_plantilla": "import time\n\ndef suma_iterativa(n):\n    # Tu código con bucle for aquí\n    pass\n\ndef suma_formula(n):\n    # Tu código con la fórmula de Gauss aquí\n    pass\n\n# Test de rendimiento\nn = 10000000 # 10 Millones\n\nstart = time.time()\nres_iter = suma_iterativa(n)\nprint(f\"Iterativa: {time.time() - start:.5f} segundos\")\n\nstart = time.time()\nres_form = suma_formula(n)\nprint(f\"Fórmula:   {time.time() - start:.5f} segundos\")\n\n# Verificación de corrección\nassert res_iter == res_form, \"¡Error! Los resultados no coinciden.\"",
      "solucion_referencia": "def suma_iterativa(n):\n    acumulador = 0\n    for i in range(1, n + 1):\n        acumulador += i\n    return acumulador\n\ndef suma_formula(n):\n    # Fórmula probada por inducción matemática P(n)\n    return (n * (n + 1)) // 2",
      "casos_prueba": [
        {
          "entrada": "n = 100",
          "salida_esperada": "5050 (Ambas funciones deben dar esto)",
          "nota": "Verificación de corrección"
        },
        {
          "entrada": "n = 10^7",
          "salida_esperada": "Iterativa: Lento (~1s) vs Fórmula: Instantáneo (~0s)",
          "nota": "Demostración de eficiencia O(1) vs O(n)"
        }
      ],
      "recursos_adicionales": [
        {
          "tipo": "video",
          "titulo": "Mathematical Induction for Computer Science",
          "url": "https://www.youtube.com/watch?v=..."
        }
      ]
    }
  }
}
